<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.63">
<title data-react-helmet="true">输入 URL 后发生什么🔥 | Hi, i am Turkyden</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="输入 URL 后发生什么🔥 | Hi, i am Turkyden"><meta data-react-helmet="true" name="description" content="如果说面试官只能问一个问题考察一个人前端知识的广度和深度的话，那一定是从输入URL到页面展示发生了什么。为什么这么说？因为从输入URL到页面展示就是前端的“核心主线”，搞清楚这个问题，就能站在更高维度去理解前端。今天就结合最近一段时间的学习和积累，争取把这条主线尽我所能地讲清楚，帮助大家的同时也帮助自己一次搞定从输入 URL 到页面展示到底发生了什么。"><meta data-react-helmet="true" property="og:description" content="如果说面试官只能问一个问题考察一个人前端知识的广度和深度的话，那一定是从输入URL到页面展示发生了什么。为什么这么说？因为从输入URL到页面展示就是前端的“核心主线”，搞清楚这个问题，就能站在更高维度去理解前端。今天就结合最近一段时间的学习和积累，争取把这条主线尽我所能地讲清楚，帮助大家的同时也帮助自己一次搞定从输入 URL 到页面展示到底发生了什么。"><meta data-react-helmet="true" property="og:url" content="https://Turkyden.github.io/docs/browser/what-happen-url"><link data-react-helmet="true" rel="shortcut icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://Turkyden.github.io/docs/browser/what-happen-url"><link rel="stylesheet" href="/styles.626fd233.css">
<link rel="preload" href="/styles.670df87a.js" as="script">
<link rel="preload" href="/runtime~main.fcfa8f25.js" as="script">
<link rel="preload" href="/main.39c27bb3.js" as="script">
<link rel="preload" href="/1.91b05bf6.js" as="script">
<link rel="preload" href="/2.5d8e3081.js" as="script">
<link rel="preload" href="/3.f9fbe2cf.js" as="script">
<link rel="preload" href="/1be78505.7492cde2.js" as="script">
<link rel="preload" href="/77.aceb1dde.js" as="script">
<link rel="preload" href="/935f2afb.399daf7f.js" as="script">
<link rel="preload" href="/17896441.5d49ec12.js" as="script">
<link rel="preload" href="/f2154559.a0d91029.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.svg" alt="My Site Logo"><strong class="navbar__title">Turkyden</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">进阶</a><a class="navbar__item navbar__link" href="/blog">专栏</a><a class="navbar__item navbar__link" href="/books">书籍</a><a class="navbar__item navbar__link" href="/motto">箴言</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Turkyden" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.svg" alt="My Site Logo"><strong class="navbar__title">Turkyden</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs">进阶</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">专栏</a></li><li class="menu__list-item"><a class="menu__link" href="/books">书籍</a></li><li class="menu__list-item"><a class="menu__link" href="/motto">箴言</a></li><li class="menu__list-item"><a href="https://github.com/Turkyden" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">前言</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/">前端知识体系</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">计算机与网络通识</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/proxy-server">代理服务器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/restful-api">Restful API</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">算法</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/algorithms">算法</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">数据结构</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/data-structure">数据结构</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">编程思想</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/thinking/design-patterns-typescript">设计模式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/thinking/clean-code-typescript">代码整洁之道</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Javascript</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/closure">闭包</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/depth-shallow-copy">深浅拷贝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/prototype">原型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/examination">高频真题🔥</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CSS</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/css/flex-layout">Flex 布局</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">浏览器</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/browser/cross-domain">跨域</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/browser/cookie">Cookie</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/browser/event">事件机制</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/browser/what-happen-url">输入 URL 后发生什么🔥</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/browser/websocket">Websocket</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">性能</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/performance/cache-policy">缓存策略</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">安全</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/security/xss">XSS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/security/csrf">CSRF</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/security/token">Token</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/security/security-code">验证码</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">React</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/react/virtual-dom">虚拟 DOM</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/react/router">路由原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/react/do-you-kown-react">你真的了解 React 吗</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/react/why-jsx">为什么 React 要使用 JSX</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/react/life-cycle">React 生命周期有哪些坑</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">TSX</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tsx/interface">接口</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">测试</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/test/test">单元测试</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">WebGL</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/mdx">Powered by MDX</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">WebAssembly</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/mdx">Powered by MDX</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">面试</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/interview/resume">个人简历</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/interview/basic">编程基础能力考查</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/interview/5-3-html">五年高考三年模拟（HTML）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/interview/5-3-css">五年高考三年模拟（CSS）</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">输入 URL 后发生什么🔥</h1></header><div class="markdown"><p>如果说面试官<strong>只能问一个问题</strong>考察一个人前端知识的广度和深度的话，那<strong>一定是从输入URL到页面展示发生了什么</strong>。为什么这么说？因为从输入URL到页面展示就是前端的“<strong>核心主线</strong>”，搞清楚这个问题，就能<strong>站在更高维度去理解前端</strong>。今天就结合最近一段时间的学习和积累，争取把这条主线尽我所能地讲清楚，帮助大家的同时也帮助自己<strong>一次搞定</strong>从输入 URL 到页面展示到底发生了什么。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="浏览器的多进程架构"></a>浏览器的多进程架构<a aria-hidden="true" tabindex="-1" class="hash-link" href="#浏览器的多进程架构" title="Direct link to heading">#</a></h2><p>在正式开始之前，我认为有必要以 Chrome 为例，介绍一下现代浏览器的多进程架构(multi-process architecture)，如下图所示：</p><p>其中主要的部分有：</p><ul><li><p>浏览器进程 (Browser Process)，也叫主进程</p><ul><li>UI 线程(UI Thread)，控制浏览器上的按钮和输入框等UI</li><li>网络线程(NetWork Thread)，负责资源的下载</li><li>存储线程(Storage Thread)，负责本地缓存文件的访问</li></ul></li><li><p>渲染进程 (Renderer Process)，也叫浏览器内核</p><ul><li>JS 引擎，负责执行 JavaScript，也是 JS 是单线程的由来</li><li>GUI 渲染线程，负责渲染资源，与 JS 引擎互斥（一个运行一个挂起）</li><li>事件触发线程，管理事件循环 (鼠标点击、setTimeout、Mutation Observer、Ajax等，按顺序把事件放到 JS 执行队列</li><li>定时器线程，<code>setTimeout</code> 并不是 JS 的功能，只是浏览器开给 JS 的一个接口</li><li>异步请求线程，处理 <strong>AJAX</strong> 请求，通过回调函数通知<strong>事件触发进程</strong></li></ul></li><li><p>GPU进程，负责与 GPU 通信</p></li><li><p>第三方插件进程，就是我们安装的浏览器插件</p></li></ul><p>说完浏览器的多进程架构，下面我们就正式开始讲<strong>浏览器从输入 URL 到页面展示到底发生了什么。</strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="1-构建请求"></a>1. 构建请求<a aria-hidden="true" tabindex="-1" class="hash-link" href="#1-构建请求" title="Direct link to heading">#</a></h2><p>输入 URL 后，主进程中的 UI 线程接受到用户的 URL，判断用户输入的是 query 还是 URL。如果是 URL，把 URL 转发给网络线程，网络线程会构建请求行信息，构建好之后，浏览器就准备发起网络请求。</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-text codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">// 请求方法是GET，路径为根路径，HTTP协议版本为1.1</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">GET / HTTP/1.1</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="2-查找强缓存"></a>2. 查找强缓存<a aria-hidden="true" tabindex="-1" class="hash-link" href="#2-查找强缓存" title="Direct link to heading">#</a></h2><p>浏览器在发起真正的网络请求前，会<strong>先检查浏览器的强缓存，如果命中，直接返回对应资源文件的副本</strong>。否则进入下一步。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="21-什么是强缓存"></a>2.1 什么是强缓存<a aria-hidden="true" tabindex="-1" class="hash-link" href="#21-什么是强缓存" title="Direct link to heading">#</a></h3><p>浏览的缓存策略分为<strong>强缓存</strong>和<strong>协商缓存</strong>，他们之间的根本区别是<strong>是否需要发请求</strong>。简单来说，强缓存就是你的本地文件（保存在硬盘或者内存中），你可以<strong>立马访问</strong>到；协商缓存是需要发请求给服务器，问问资源是否有更新，<strong>如果没有更新就访问本地缓存；如果更新，服务器会返回更新后的资源文件</strong>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="22-强缓存的实现"></a>2.2 强缓存的实现<a aria-hidden="true" tabindex="-1" class="hash-link" href="#22-强缓存的实现" title="Direct link to heading">#</a></h3><p>在 HTTP/1.0 时代，强缓存是通过 HTTP 响应头中 <strong>Expires</strong> 字段实现的，Expires 的意思是过期，所以这个字段的内容就是一个<strong>绝对的失效时间</strong>，例如 <code>Expires:Wed, 05 Apr 2020 00:55:35 GMT</code>。浏览器通过这个失效时间和用户的<strong>本地时间</strong>相比较来判定是否读取缓存中的资源副本，这就带来一个很明显的问题，用户可以自己修改本地时间，使缓存失效。</p><p>所以 HTTP/1.1 中新加入了 <strong>Cache-Control</strong> 字段来解决这个问题，通过设置 <code>cache-control: max-age=XXX</code>，可以实现缓存在 XXX 秒后过期（<strong>相对时间</strong>），这样就规避了用户可以自己篡改本地时间使缓存失效的问题。</p><p>在 <code>cache-control</code> 和 <code>Expires</code> 同时存在时，以 <code>cache-control</code> 优先。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="3-dns-解析"></a>3. DNS 解析<a aria-hidden="true" tabindex="-1" class="hash-link" href="#3-dns-解析" title="Direct link to heading">#</a></h2><p>发送真正网络请求首先需要进行 DNS 解析，目的就是<strong>找到 URL 对应的服务器 IP 地址</strong>。关于 DNS 解析的过程，我简单介绍一下，大致是先查找本地 DNS 缓存，找不到就问本地 DNS 服务器，再依次问根域 DNS 服务器，一级域名服务器，二级域名服务器，最后把找到的 IP 地址层层传递回来。这里再放一张图帮助大家更直观地理解。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="4-建立-tcp-连接"></a>4. 建立 TCP 连接<a aria-hidden="true" tabindex="-1" class="hash-link" href="#4-建立-tcp-连接" title="Direct link to heading">#</a></h2><p>知道服务器的 IP 地址后，就可以跟服务器正式建立连接了，连接的方式分为两种，可靠的 TCP 和不可靠的 UDP，HTTP 协议是基于 TCP 的，所以需要跟服务器建立 TCP 连接。怎么建立呢？通过三次握手。三次握手的流程如下图所示。</p><p>那么大家有没有想过，为什么一定要三次握手，而不是两次或者一次呢？</p><p>是因为<strong>浏览器和服务器都需要确认对方有正常的收发能力</strong>。如果两次握手的话，客户端能知道服务端能收能发，但服务端只能知道客户端能发送数据，<strong>并不知道客户端接受数据是没问题的</strong>，大家把上图的第三次握手遮掉，想想看是不是这样？</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="5-发送请求，收到响应"></a>5. 发送请求，收到响应<a aria-hidden="true" tabindex="-1" class="hash-link" href="#5-发送请求，收到响应" title="Direct link to heading">#</a></h2><p>建立了 TCP 连接，浏览器就可以和服务器进行通信了，HTTP 中的数据就是在这个通信过程中传输的。下面是一个 HTTP 请求的完整示例。</p><p>服务器收到 HTTP 请求后，会返回给浏览器 HTTP 响应，下面是一个 HTTP 响应的完整示例。</p><p>服务器会通过响应行中的<strong>状态码</strong>告诉浏览器它的处理结果，常见的状态码有以下几类：</p><ul><li>2XX：成功，最常见的是 200 OK</li><li>3XX：需要进一步操作，比如 301 永久重定向，302 临时重定向，304 未修改</li><li>4XX：请求出错，比如最常见的 404 未找到资源，还有 403 禁止请求</li><li>5XX：服务器出错，比如 500 服务器内部错误，502 网关错误</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="6查找协商缓存"></a>6.查找协商缓存<a aria-hidden="true" tabindex="-1" class="hash-link" href="#6查找协商缓存" title="Direct link to heading">#</a></h2><p>在上一步中如果 HTTP 响应行中的状态码为 304 (Not Modified 未修改)，内容为空时，那么就相当于告诉浏览器“<strong>服务器上的资源跟你本地缓存的副本一样，从缓存中拿就行啦</strong>”。这就是协商缓存的流程，<strong>当强缓存过期</strong>，或者 <code>cache-control</code> 设置 <code>no-cache</code> 时，就会进行协商缓存，浏览器会发送请求到服务器，根据响应头中的状态码判断是否要从缓存中读取。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="61-协商缓存的实现"></a>6.1 协商缓存的实现<a aria-hidden="true" tabindex="-1" class="hash-link" href="#61-协商缓存的实现" title="Direct link to heading">#</a></h3><p>协商缓存是通过 HTTP/1.0 中的 <strong>Last-Modified</strong> 和 HTTP/1.1 中的 <strong>E-Tag</strong> 实现的。</p><p>Last-Modified 验证规则：浏览器第一次发送请求，服务器在响应头中带上 <code>Last-Modified</code>，并返回资源，浏览器下次发送相同请求时，会把之前收到的 Last-Modified 内容放到请求头中的 <code>If-Modified-Since</code> 字段，服务器收到后会跟请求资源的最后修改时间做对比，如果相同，返回 HTTP 304，如果不相同，返回 HTTP 200，并返回最新的资源。详细的过程可以查看下图：</p><p>E-Tag 验证规则：验证过程跟 <code>Last-Modified</code> 类似，只不过是浏览器第一次收到的是 <code>etag</code>，第二次发送的是 <code>If-None-Match</code>。跟 <code>Last-Modified</code> 的区别是 <code>E-Tag</code> 的内容是资源的唯一标识符，<code>Last-Modified</code> 的内容是最后修改时间，且 E-Tag 优先级高于 Last-Modified。</p><p>想必你会好奇，既然功能一样，为什么 HTTP/1.1 要引入 E-Tag 实现协商缓存呢？</p><p>其原因在于：</p><ul><li>有些资源会被周期性的重写，但内容完全一样</li><li>有些资源可能被修改，但修改完全没必要让用户重新下载（修改注释或拼写）</li><li>有些资源的变化时间会小于一秒（比如实时监视器），所以 Last-Modified 的时间粒度不够了</li></ul><p>这几种情况下，唯一标识资源的 E-Tag 就比 Last-Modified 管用啦。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="7-断开-tcp-连接"></a>7. 断开 TCP 连接<a aria-hidden="true" tabindex="-1" class="hash-link" href="#7-断开-tcp-连接" title="Direct link to heading">#</a></h2><p>浏览器接受完服务器返回的资源后，需要断开 TCP 连接。断开 TCP 连接需要经历四次挥手。下图展示了四次挥手的过程。</p><p>那么为什么要四次挥手，而不是三次？</p><p>因为<strong>多了服务端通知客户端数据发送完毕的第三次挥手</strong>。大家想想，如果没有第三次挥手，而是客户端直接确认关闭连接的第四次挥手，客户端就无法收到服务器还没发完的数据，导致<strong>数据丢失</strong>。传输数据要有始有终，不得不佩服发明 TCP 协议的罗伯特·卡恩和文顿·瑟夫两位大佬，40多年前就发明出了如此严谨的数据传输协议。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="8-解析-html，构建-dom-树"></a>8. 解析 HTML，构建 DOM 树<a aria-hidden="true" tabindex="-1" class="hash-link" href="#8-解析-html，构建-dom-树" title="Direct link to heading">#</a></h2><p>完成上面的网络请求过程后，接下来就是浏览器的渲染进程解析和渲染资源的过程了。首先对于 HTML 文件，浏览器由它生成 DOM 树（一种浏览器可以理解的树形结构，全称是 Document Object Model）。</p><p><strong>那么浏览器具体是是如何构建 DOM 树的呢？通过以下四步。</strong></p><ol><li><strong>转换 (Conversion)</strong>。浏览器读取原始字节形式的 HTML，并按照指定的格式（例如 UTF-8）把这些字节翻译成单个字符。</li><li><strong>序列化 (Tokenizing)</strong>。浏览器把第一步得到的字符串转换成不同的标记，例如 <code>&lt;html&gt;</code>, <code>&lt;body&gt;</code> 等，每个标记都有自己的含义和规则。</li><li><strong>词法分析 (Lexing)</strong>。把这些标记转换为“对象”，来定义其属性和规则。</li><li><strong>构建 DOM (DOM construction)</strong>。因为 HTML 标签有特定的包含规则，比如 html 包含 body，body 包含 div，我们又通过上一步生成的对象知道了标签之间的父子关系，所以就可以构建出 DOM 树。</li></ol><p>每次浏览器处理 HTML 文件，都会经历上面的四个过程。在 HTML 比较复杂时，整个流程可能会比较费时。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="9-样式计算，构建-cssom-树"></a>9. 样式计算，构建 CSSOM 树<a aria-hidden="true" tabindex="-1" class="hash-link" href="#9-样式计算，构建-cssom-树" title="Direct link to heading">#</a></h2><p>样式计算的目的是为了计算出上面 DOM 节点中每个元素的具体样式，这个阶段大体可以分成三步：</p><p><strong>一）把 CSS 转化为浏览器能够理解的结构 styleSheets</strong></p><p>跟 HTML 文本一样，浏览器是无法直接理解纯文本的 CSS 样式，所以<strong>渲染进程在接受到 CSS 文本时，会先执行一个转化操作，将 CSS 文本转化成浏览器能够理解的结构 styleSheets。</strong></p><p>在 Chrome 控制台中输入 <code>document.styleSheets</code> 就可以看到如下结构：</p><p><strong>二）转换样式表中的属性值，使其标准化</strong></p><p><strong>三）计算出 DOM 树中每个节点的具体样式</strong></p><p>样式的属性已经被标准化了，接下来就是要计算 DOM 树中每个节点的样式属性了，如何计算呢？</p><p>这里就会涉及到 CSS 的<strong>继承规则</strong>和<strong>层叠规则</strong>了。</p><p><strong>首先是 CSS 继承</strong>，CSS 继承就是每个 <strong>DOM 节点都会继承其父节点的样式</strong>。下图能比较清晰地展示样式的继承过程：</p><p><strong>其次是样式层叠</strong>，CSS 的全称就叫“层叠样式表”。关于层叠顺序，这里又可以引出 CSS 选择器的优先级：</p><ul><li>内联 style &gt; id &gt; class &gt; 标签</li><li>内联 style &gt; 内部 style &gt; 外部 CSS文件</li><li>一般来讲，越具体优先级越高，<code>!important</code> 的优先级最高，但是要<strong>慎用</strong>。</li></ul><p>经过计算后就会生成 CSSOM (CSS Object Model) 树 ，大致如下图所示：</p><p>让我们回顾一下浏览器处理 CSS 的过程，其实<strong>跟 HTML 是很类似的，从字节开始，翻译成字符、序列化、生成节点，最终生成 CSSOM (CSS Object Model)。</strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="10-布局"></a>10. 布局<a aria-hidden="true" tabindex="-1" class="hash-link" href="#10-布局" title="Direct link to heading">#</a></h2><p>我们虽然有 DOM 树和 DOM 树中每个节点的样式，但还不知道这些 DOM 元素的几何位置，所以接下来就需要计算出 DOM 树中可见元素的几何位置。我们把这个计算过程叫做布局。布局阶段可以分成两个子阶段，<strong>创建布局树</strong>和<strong>布局计算</strong>。</p><p><strong>布局树的构造过程</strong>大概是这样：</p><p>我们可以观察到 DOM 树中所有 <code>display: none</code> 的节点都没有出现在布局树中。所以构建布局树的过程可以简单总结如下：</p><ul><li><strong>遍历 DOM 树中的所有可见节点</strong>，并把这些节点加到布局树中</li><li><strong>不可见节点会被布局树忽略</strong>，如 <code>head</code> 标签下的全部内容，以及样式为 <code>display: none</code> 的元素</li></ul><p>构建完布局树，接下来就是<strong>计算布局树节点的实际坐标</strong>了。至于具体的计算过程非常的复杂，我们暂且跳过，等待日后补充。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="11-生成图层树"></a>11. 生成图层树<a aria-hidden="true" tabindex="-1" class="hash-link" href="#11-生成图层树" title="Direct link to heading">#</a></h2><p>有了布局树，而且还计算除了每个元素的具体位置信息，那么接下来可以开始绘制了吗？其实不是的。<strong>在绘制之前，还有一个生成图层树 (Layer Tree) 的过程</strong>。</p><p>为什么需要先生成图层树呢？<strong>因为现代的前端页面有着非常复杂多样的效果，比如页面滚动、z-index 方向上的排序等，为了更加方便地实现这些效果，渲染进程还需要为特定的节点生成专用的图层，并生成一颗对应的图层树 (Layer Tree)</strong>。布局树和图层树的对应关系大致如下：</p><p>那么问题来了，<strong>需要什么样的条件，渲染进程才会为特定节点创建新的图层呢？</strong></p><p><strong>一）拥有层叠上下文属性的元素会被提升为单独一层</strong></p><p>页面是二维平面，但层叠上下文能够让 HTML 具有三维概念。这些 HTML 元素会按照他们的优先级分布在垂直于二维平面的 z 轴上。具体的优先级顺序如下：</p><p>正 z-index &gt; z-index = 0 &gt; inline &gt; float &gt; block &gt; 负 z-index &gt; border &gt; background</p><p><strong>二）需要裁剪的地方也会被创建为图层</strong></p><p>裁剪的意思就是<strong>要显示的内容超出它的容器</strong>（比如 200 x 200 像素的 div 里面里面放着 1000 个字），另外如果出现滚动条，<strong>滚动条也会被提升为单独的层</strong>，类似下图这样。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="12-绘制"></a>12. 绘制<a aria-hidden="true" tabindex="-1" class="hash-link" href="#12-绘制" title="Direct link to heading">#</a></h2><p>完成构建图层树之后，接下来就是渲染引擎对图层树中每个图层的绘制，具体的实现是渲染引擎会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制的列表，就像下图这样。</p><p>我们可以打开 Chrome 开发者工具的 Layers 标签，选择 &quot;document&quot; 层，实际体验下绘制列表的过程。给大家一个示意图作参考：</p><p>图中圈出来的就是 document 的绘制列表，拖动右侧的进度条就可以重现列表的绘制过程，是不是非常神奇呢？</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="13-栅格化"></a>13. 栅格化<a aria-hidden="true" tabindex="-1" class="hash-link" href="#13-栅格化" title="Direct link to heading">#</a></h2><p>生成绘制列表后，会进行<strong>栅格化。绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的</strong>。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p><p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交（commit）</strong>给合成线程，那么接下来合成线程是怎么工作的呢？这里需要先引入一个做过 H5 手机页面开发的都会比较熟悉的标签：</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code></p><p>这里面的 viewport 就是用户可以实际看到的部分，中文翻译叫做<strong>视口</strong>。</p><p><strong>很多时候，页面的长度都是远大于屏幕高度的，所以图层都会比较大，但是通过视口，用户只能看到其中一部分内容，所以在这种情况下，要一次性绘制出所有图层内容的话，就会产生非常大的开销，而且也没有必要。</strong></p><p>基于这个原因，<strong>合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512</strong>，如下图所示：</p><p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作就是由栅格化来执行的。所谓的栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，其运行方式如下图所示：</p><p>通常，<strong>栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="14-合成与显示"></a>14. 合成与显示<a aria-hidden="true" tabindex="-1" class="hash-link" href="#14-合成与显示" title="Direct link to heading">#</a></h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。这个过程可以用下图表示：</p><p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p><p><strong>渲染流水线总结</strong></p><p>下面用一张图总结一下从收到服务器发来的资源后的整个渲染和显示过程，我们把这个过程称为<strong>渲染流水线</strong>。</p><p>结合上图，一个完整的渲染流程大致可总结为如下：</p><ol><li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算并生成 CSSOM 树。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成图层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li><li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="结语"></a>结语<a aria-hidden="true" tabindex="-1" class="hash-link" href="#结语" title="Direct link to heading">#</a></h2><p>完整的从输入URL到页面展示的全过程大概就是这样，其中的每一个过程都可以延伸出非常多的知识。如果其中某些部分大家想要理解地更加透彻，可以看看下面的参考链接。在不断打磨之后，最大的收获有两点：</p><p>通过对某个领域<strong>主线知识</strong>的深入挖掘，我们就能<strong>把离散的知识串起来，形成体系</strong>
其实学习任何领域都是一个把知识先变厚再变薄的过程，但<strong>千万不能只有厚没有薄</strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="reffers"></a>Reffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#reffers" title="Direct link to heading">#</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/190320054" target="_blank" rel="noopener noreferrer">[1] 从输入URL到页面展示发生了什么·习本非表</a></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Turkyden/edit/master/docs/browser/what-happen-url.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/browser/event"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 事件机制</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/browser/websocket"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Websocket »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#浏览器的多进程架构" class="table-of-contents__link">浏览器的多进程架构</a></li><li><a href="#1-构建请求" class="table-of-contents__link">1. 构建请求</a></li><li><a href="#2-查找强缓存" class="table-of-contents__link">2. 查找强缓存</a><ul><li><a href="#21-什么是强缓存" class="table-of-contents__link">2.1 什么是强缓存</a></li><li><a href="#22-强缓存的实现" class="table-of-contents__link">2.2 强缓存的实现</a></li></ul></li><li><a href="#3-dns-解析" class="table-of-contents__link">3. DNS 解析</a></li><li><a href="#4-建立-tcp-连接" class="table-of-contents__link">4. 建立 TCP 连接</a></li><li><a href="#5-发送请求，收到响应" class="table-of-contents__link">5. 发送请求，收到响应</a></li><li><a href="#6查找协商缓存" class="table-of-contents__link">6.查找协商缓存</a><ul><li><a href="#61-协商缓存的实现" class="table-of-contents__link">6.1 协商缓存的实现</a></li></ul></li><li><a href="#7-断开-tcp-连接" class="table-of-contents__link">7. 断开 TCP 连接</a></li><li><a href="#8-解析-html，构建-dom-树" class="table-of-contents__link">8. 解析 HTML，构建 DOM 树</a></li><li><a href="#9-样式计算，构建-cssom-树" class="table-of-contents__link">9. 样式计算，构建 CSSOM 树</a></li><li><a href="#10-布局" class="table-of-contents__link">10. 布局</a></li><li><a href="#11-生成图层树" class="table-of-contents__link">11. 生成图层树</a></li><li><a href="#12-绘制" class="table-of-contents__link">12. 绘制</a></li><li><a href="#13-栅格化" class="table-of-contents__link">13. 栅格化</a></li><li><a href="#14-合成与显示" class="table-of-contents__link">14. 合成与显示</a></li><li><a href="#结语" class="table-of-contents__link">结语</a></li><li><a href="#reffers" class="table-of-contents__link">Reffers</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Resources</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Facebook React</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Alibaba Hooks</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Ant Design</a></li><li class="footer__item"><a href="https://storyset.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Story Set</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">知乎</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">掘金</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Dribbble</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/Turkyden" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright © 2020. Created with ❤ by Turkyden.</div></div></div></footer></div>
<script src="/styles.670df87a.js"></script>
<script src="/runtime~main.fcfa8f25.js"></script>
<script src="/main.39c27bb3.js"></script>
<script src="/1.91b05bf6.js"></script>
<script src="/2.5d8e3081.js"></script>
<script src="/3.f9fbe2cf.js"></script>
<script src="/1be78505.7492cde2.js"></script>
<script src="/77.aceb1dde.js"></script>
<script src="/935f2afb.399daf7f.js"></script>
<script src="/17896441.5d49ec12.js"></script>
<script src="/f2154559.a0d91029.js"></script>
</body>
</html>